#include "ros/ros.h"//Used for launch file parameter parsing
#include <string>//Used for rois message vector
#include <vector>
#include <sstream>

//Included for files
#include <iostream>
#include <fstream>
#include "stdio.h"
#include "dirent.h"

//Publish Messages
#include "std_msgs/String.h"
#include "opt_msgs/Track.h"

//Time Synchronizer
// NOTE: Time Synchronizer conflicts with QT includes may need to investigate
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>

#include <message_filters/sync_policies/approximate_time.h>

//Subscribe Messages
#include <sensor_msgs/Image.h>
#include <sensor_msgs/CameraInfo.h>
#include <sensor_msgs/image_encodings.h>
#include <cv_bridge/cv_bridge.h>

// Image Transport
#include <image_transport/image_transport.h>
#include <image_transport/subscriber_filter.h>

// Used to display OPENCV images
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

#include <boost/filesystem.hpp>


//using namespace sensor_msgs;
using namespace message_filters::sync_policies;
using namespace sensor_msgs::image_encodings;
using namespace opt_msgs;
using namespace cv;

//NOTE: Where is the best place to put these
//typedef ApproximateTime<Image, opt_msgs::Track> ApproximatePolicy;
//typedef message_filters::Synchronizer<ApproximatePolicy> ApproximateSync;

cv::Scalar darkBlue(130,0,0);
cv::Scalar white(255,255,255);

class targetViewerNode
{
  private:
    // Define Node
    ros::NodeHandle node_;

    // Subscribe to Messages
    message_filters::Subscriber<sensor_msgs::Image> sub_image_;
    message_filters::Subscriber<opt_msgs::Track> sub_track_;

    // Define the Synchronizer
    typedef ApproximateTime<sensor_msgs::Image, opt_msgs::Track> ApproximatePolicy;
    typedef message_filters::Synchronizer<ApproximatePolicy > ApproximateSync;
    boost::shared_ptr<ApproximateSync > approximate_sync_;

    // Launch file Parameters
    bool color_image;

  public:

    explicit targetViewerNode(const ros::NodeHandle& nh):
    node_(nh)
    {

      //Read mode from launch file
      std::string mode="";
      node_.param(ros::this_node::getName() + "/mode", mode, std::string("none"));
      ROS_INFO("Selected mode: %s",mode.c_str());

      if(mode.compare("roi_display")==0){
        ROS_INFO("MODE: %s",mode.c_str());

        //Read parameter stating if the image is grayscale or with colors
        node_.param(ros::this_node::getName()+"/color_image", color_image, true);

        // Subscribe to Messages
        sub_image_.subscribe(node_,"input_image",20);
        sub_track_.subscribe(node_,"input_track",20);

        // Sync the Synchronizer
        approximate_sync_.reset(new ApproximateSync(ApproximatePolicy(20), sub_image_, sub_track_));

        /*approximate_sync_->registerCallback(boost::bind(&targetViewerNode::imageCb,
            this,
            _1,
            _2));
      */}else{

        ROS_INFO("Unknown mode:%s  Please set to {roi_display} in targetViewer.launch",mode.c_str());
      }
      // Visualization
      cv::namedWindow("Target", 0 ); // non-autosized
      cv::startWindowThread();

    }

    void imageCb(const sensor_msgs::ImageConstPtr& image_msg, const opt_msgs::Track::ConstPtr& track_msg){

      std::string filename = image_msg->header.frame_id.c_str();
      std::string imgName = filename.substr(filename.find_last_of("/")+1);

      //ROS_INFO("targetViewer Callback called for image: %s", imgName.c_str());

      //Use CV Bridge to convert images
      cv_bridge::CvImagePtr cv_ptr;
      if (color_image)
      {
        cv_ptr = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8);
      }
      else
      {
        cv_ptr = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::MONO8);
      }

			int x = track_msg->box_2D.x + 0.125*track_msg->box_2D.width;
			int y = track_msg->box_2D.y - 0.02*track_msg->box_2D.height;
			int w = 0.75*track_msg->box_2D.width;
			int h = 0.5*track_msg->box_2D.height;

			Rect rect(x,y,w,h);

			if (rect.area() > 0)
				rectangle(cv_ptr->image, rect, Scalar(255,255,255));

      // Display the cv image
      cv::imshow("Target",cv_ptr->image);
			cv::waitKey(10);
    }

    ~targetViewerNode()
    {
    }
};

int main(int argc, char **argv)
{
  ros::init(argc, argv, "targetViewer");
  ros::NodeHandle n;
  targetViewerNode targetViewerNode(n);

  ros::spin();

	destroyWindow("Target");

  return 0;
}

